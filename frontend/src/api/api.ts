/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI Test Blog
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {User}
     * @memberof InlineResponse200
     */
    data?: User;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {Array<User>}
     * @memberof InlineResponse2001
     */
    data?: Array<User>;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * 
     * @type {Post}
     * @memberof InlineResponse2002
     */
    data?: Post;
}
/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * 
     * @type {Array<Post>}
     * @memberof InlineResponse2003
     */
    data?: Array<Post>;
}
/**
 * 
 * @export
 * @interface Post
 */
export interface Post {
    /**
     * 
     * @type {number}
     * @memberof Post
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Post
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof Post
     */
    body?: string;
    /**
     * 
     * @type {User}
     * @memberof Post
     */
    author?: User;
}
/**
 * 
 * @export
 * @interface PostStoreRequest
 */
export interface PostStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof PostStoreRequest
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof PostStoreRequest
     */
    body?: string;
}
/**
 * 
 * @export
 * @interface PostUpdateRequest
 */
export interface PostUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof PostUpdateRequest
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof PostUpdateRequest
     */
    body?: string;
}
/**
 * User account that can post and comment on the blog.
 * @export
 * @interface User
 */
export interface User {
    /**
     * The user\'s primary key.
     * @type {number}
     * @memberof User
     */
    id?: number;
    /**
     * The user\'s name.
     * @type {string}
     * @memberof User
     */
    name?: string;
    /**
     * The user\'s email.
     * @type {string}
     * @memberof User
     */
    email?: string;
    /**
     * 
     * @type {Array<Post>}
     * @memberof User
     */
    posts?: Array<Post>;
}
/**
 * 
 * @export
 * @interface UserAuthenticateRequest
 */
export interface UserAuthenticateRequest {
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticateRequest
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof UserAuthenticateRequest
     */
    password?: string;
}
/**
 * 
 * @export
 * @interface UserStoreRequest
 */
export interface UserStoreRequest {
    /**
     * 
     * @type {string}
     * @memberof UserStoreRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof UserStoreRequest
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof UserStoreRequest
     */
    password?: string;
}

/**
 * CsrfCookieApi - axios parameter creator
 * @export
 */
export const CsrfCookieApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return an empty response simply to trigger the storage of the CSRF cookie in the browser.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        csrfCookieGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/sanctum/csrf-cookie`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CsrfCookieApi - functional programming interface
 * @export
 */
export const CsrfCookieApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Return an empty response simply to trigger the storage of the CSRF cookie in the browser.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async csrfCookieGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await CsrfCookieApiAxiosParamCreator(configuration).csrfCookieGet(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CsrfCookieApi - factory interface
 * @export
 */
export const CsrfCookieApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Return an empty response simply to trigger the storage of the CSRF cookie in the browser.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        csrfCookieGet(options?: any): AxiosPromise<void> {
            return CsrfCookieApiFp(configuration).csrfCookieGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CsrfCookieApi - object-oriented interface
 * @export
 * @class CsrfCookieApi
 * @extends {BaseAPI}
 */
export class CsrfCookieApi extends BaseAPI {
    /**
     * Return an empty response simply to trigger the storage of the CSRF cookie in the browser.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CsrfCookieApi
     */
    public csrfCookieGet(options?: any) {
        return CsrfCookieApiFp(this.configuration).csrfCookieGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PostApi - axios parameter creator
 * @export
 */
export const PostApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete the selected post.
         * @param {string} post Id of the Post to destroy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDestroy: async (post: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'post' is not null or undefined
            if (post === null || post === undefined) {
                throw new RequiredError('post','Required parameter post was null or undefined when calling postDestroy.');
            }
            const localVarPath = `/api/posts/{post}`
                .replace(`{${"post"}}`, encodeURIComponent(String(post)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all posts.
         * @param {boolean} [withAuthor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postIndex: async (withAuthor?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/posts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (withAuthor !== undefined) {
                localVarQueryParameter['withAuthor'] = withAuthor;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Show the selected post.
         * @param {string} post Id of the Post to show
         * @param {boolean} [withAuthor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postShow: async (post: string, withAuthor?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'post' is not null or undefined
            if (post === null || post === undefined) {
                throw new RequiredError('post','Required parameter post was null or undefined when calling postShow.');
            }
            const localVarPath = `/api/posts/{post}`
                .replace(`{${"post"}}`, encodeURIComponent(String(post)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (withAuthor !== undefined) {
                localVarQueryParameter['withAuthor'] = withAuthor;
            }


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new post.
         * @param {PostStoreRequest} [postStoreRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postStore: async (postStoreRequest?: PostStoreRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/posts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof postStoreRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(postStoreRequest !== undefined ? postStoreRequest : {}) : (postStoreRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the selected post.
         * @param {string} post Id of the Post to update
         * @param {PostUpdateRequest} [postUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUpdate: async (post: string, postUpdateRequest?: PostUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'post' is not null or undefined
            if (post === null || post === undefined) {
                throw new RequiredError('post','Required parameter post was null or undefined when calling postUpdate.');
            }
            const localVarPath = `/api/posts/{post}`
                .replace(`{${"post"}}`, encodeURIComponent(String(post)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof postUpdateRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(postUpdateRequest !== undefined ? postUpdateRequest : {}) : (postUpdateRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PostApi - functional programming interface
 * @export
 */
export const PostApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete the selected post.
         * @param {string} post Id of the Post to destroy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postDestroy(post: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await PostApiAxiosParamCreator(configuration).postDestroy(post, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Show all posts.
         * @param {boolean} [withAuthor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postIndex(withAuthor?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await PostApiAxiosParamCreator(configuration).postIndex(withAuthor, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Show the selected post.
         * @param {string} post Id of the Post to show
         * @param {boolean} [withAuthor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postShow(post: string, withAuthor?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await PostApiAxiosParamCreator(configuration).postShow(post, withAuthor, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a new post.
         * @param {PostStoreRequest} [postStoreRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postStore(postStoreRequest?: PostStoreRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await PostApiAxiosParamCreator(configuration).postStore(postStoreRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update the selected post.
         * @param {string} post Id of the Post to update
         * @param {PostUpdateRequest} [postUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUpdate(post: string, postUpdateRequest?: PostUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await PostApiAxiosParamCreator(configuration).postUpdate(post, postUpdateRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * PostApi - factory interface
 * @export
 */
export const PostApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Delete the selected post.
         * @param {string} post Id of the Post to destroy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postDestroy(post: string, options?: any): AxiosPromise<void> {
            return PostApiFp(configuration).postDestroy(post, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all posts.
         * @param {boolean} [withAuthor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postIndex(withAuthor?: boolean, options?: any): AxiosPromise<InlineResponse2003> {
            return PostApiFp(configuration).postIndex(withAuthor, options).then((request) => request(axios, basePath));
        },
        /**
         * Show the selected post.
         * @param {string} post Id of the Post to show
         * @param {boolean} [withAuthor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postShow(post: string, withAuthor?: boolean, options?: any): AxiosPromise<InlineResponse2002> {
            return PostApiFp(configuration).postShow(post, withAuthor, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new post.
         * @param {PostStoreRequest} [postStoreRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postStore(postStoreRequest?: PostStoreRequest, options?: any): AxiosPromise<InlineResponse2002> {
            return PostApiFp(configuration).postStore(postStoreRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the selected post.
         * @param {string} post Id of the Post to update
         * @param {PostUpdateRequest} [postUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUpdate(post: string, postUpdateRequest?: PostUpdateRequest, options?: any): AxiosPromise<InlineResponse2002> {
            return PostApiFp(configuration).postUpdate(post, postUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PostApi - object-oriented interface
 * @export
 * @class PostApi
 * @extends {BaseAPI}
 */
export class PostApi extends BaseAPI {
    /**
     * Delete the selected post.
     * @param {string} post Id of the Post to destroy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostApi
     */
    public postDestroy(post: string, options?: any) {
        return PostApiFp(this.configuration).postDestroy(post, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all posts.
     * @param {boolean} [withAuthor] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostApi
     */
    public postIndex(withAuthor?: boolean, options?: any) {
        return PostApiFp(this.configuration).postIndex(withAuthor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show the selected post.
     * @param {string} post Id of the Post to show
     * @param {boolean} [withAuthor] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostApi
     */
    public postShow(post: string, withAuthor?: boolean, options?: any) {
        return PostApiFp(this.configuration).postShow(post, withAuthor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new post.
     * @param {PostStoreRequest} [postStoreRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostApi
     */
    public postStore(postStoreRequest?: PostStoreRequest, options?: any) {
        return PostApiFp(this.configuration).postStore(postStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the selected post.
     * @param {string} post Id of the Post to update
     * @param {PostUpdateRequest} [postUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PostApi
     */
    public postUpdate(post: string, postUpdateRequest?: PostUpdateRequest, options?: any) {
        return PostApiFp(this.configuration).postUpdate(post, postUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Authenticate with email and password.
         * @param {UserAuthenticateRequest} [userAuthenticateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAuthenticate: async (userAuthenticateRequest?: UserAuthenticateRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/authenticate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof userAuthenticateRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(userAuthenticateRequest !== undefined ? userAuthenticateRequest : {}) : (userAuthenticateRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Show all users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userIndex: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Show the selected user.
         * @param {string} user Id of the User to show
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userShow: async (user: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling userShow.');
            }
            const localVarPath = `/api/users/{user}`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Show the current user corresponding to the access token or session cookie.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userShowCurrent: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Register a new user.
         * @param {UserStoreRequest} [userStoreRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userStore: async (userStoreRequest?: UserStoreRequest, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof userStoreRequest !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(userStoreRequest !== undefined ? userStoreRequest : {}) : (userStoreRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Authenticate with email and password.
         * @param {UserAuthenticateRequest} [userAuthenticateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAuthenticate(userAuthenticateRequest?: UserAuthenticateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).userAuthenticate(userAuthenticateRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Show all users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userIndex(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).userIndex(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Show the selected user.
         * @param {string} user Id of the User to show
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userShow(user: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).userShow(user, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Show the current user corresponding to the access token or session cookie.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userShowCurrent(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).userShowCurrent(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Register a new user.
         * @param {UserStoreRequest} [userStoreRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userStore(userStoreRequest?: UserStoreRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).userStore(userStoreRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Authenticate with email and password.
         * @param {UserAuthenticateRequest} [userAuthenticateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAuthenticate(userAuthenticateRequest?: UserAuthenticateRequest, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).userAuthenticate(userAuthenticateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Show all users.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userIndex(options?: any): AxiosPromise<InlineResponse2001> {
            return UserApiFp(configuration).userIndex(options).then((request) => request(axios, basePath));
        },
        /**
         * Show the selected user.
         * @param {string} user Id of the User to show
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userShow(user: string, options?: any): AxiosPromise<InlineResponse200> {
            return UserApiFp(configuration).userShow(user, options).then((request) => request(axios, basePath));
        },
        /**
         * Show the current user corresponding to the access token or session cookie.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userShowCurrent(options?: any): AxiosPromise<InlineResponse200> {
            return UserApiFp(configuration).userShowCurrent(options).then((request) => request(axios, basePath));
        },
        /**
         * Register a new user.
         * @param {UserStoreRequest} [userStoreRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userStore(userStoreRequest?: UserStoreRequest, options?: any): AxiosPromise<InlineResponse200> {
            return UserApiFp(configuration).userStore(userStoreRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Authenticate with email and password.
     * @param {UserAuthenticateRequest} [userAuthenticateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userAuthenticate(userAuthenticateRequest?: UserAuthenticateRequest, options?: any) {
        return UserApiFp(this.configuration).userAuthenticate(userAuthenticateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show all users.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userIndex(options?: any) {
        return UserApiFp(this.configuration).userIndex(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show the selected user.
     * @param {string} user Id of the User to show
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userShow(user: string, options?: any) {
        return UserApiFp(this.configuration).userShow(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Show the current user corresponding to the access token or session cookie.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userShowCurrent(options?: any) {
        return UserApiFp(this.configuration).userShowCurrent(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register a new user.
     * @param {UserStoreRequest} [userStoreRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userStore(userStoreRequest?: UserStoreRequest, options?: any) {
        return UserApiFp(this.configuration).userStore(userStoreRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


